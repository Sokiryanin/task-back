Робота з Node.js

1. npm init -y ініціалізація проєкту
2. встановлюємо всі необхідні залежності
3. Додаємо файл index.js
4. Прописуємо скрипт для запуску проєкта в package.json: "scripts": {"start": "node index"};
5. Встановлюємо nodemon для автоматичного перезапуску проєкта. 
6. --save-dev - скорочення -D
7. Прописуємо скрипт для запуску проєкта в package.json: "scripts:dev": {"start": "nodemon index"};
8. Команда для запуску проєкту npm run start:dev
9. Імпорт/експорт Якщо є декілька функцій які обробляють якесь завдання, їх потрібно перекинути в загальну папку та створити всередині цієї папки файл index.js для експорту всіх файлів в цій папці. (CommonJS);
10. Якщо ми хочемо писати на ES6 модулях нам потрібно в package.json дописати "type": "module".
11. Імпорт/експорт в ES6 модулях: 

варіант 1: 

шлях dateFunc > getCurrentMonth.js: 

const getCurrentMonth = () => {
  const now = new Date();
  return now.getMonth() + 1;
};

export default getCurrentMonth;

шлях dateFunc > isLeepYear.js: 

const isLeepYear = () => {
  console.log("leep year");
};

export default isLeepYear;

шлях dateFunc > index.js:

export { default as getCurrentMonth } from "./getCurrentMonth.js";
export { default as isLeepYear } from "./isLeepYear.js";

src > index.js: 
імпорт в основний index.js
import { getCurrentMonth, isLeepYear } from "./dateFunc/index.js";

12. Робота в файлами. Читання!

Пишемо import fs from "fs/promises"; та в цому файлі прописуємо асинхронну ф-цію:

варіант 1:
const filepath = "./files/file.txt";
const func = async () => {
  const result = await fs.readFile("./files/file.txt");
  треба result привести до string: 
    const text = buffer.toString();
    text - наш текст із файла
};

або передати спосіб кодування, варіант 2:

const func = async () => {
  const text = await fs.readFile(filepath, "utf-8");
  console.log(text);
};

або можно викростита пакет detect-file-encoding-and-language, варіант 3: 

const func = async () => {
  const text = await detectFileEncoding(filepath);
  console.log(text);
};

Дописування в файл. fs.appendFile();

Оновлення файлу, перезапис. fs.writeFile();

видалення файлу fs.unlink();

<< Створення своєї бази данних: >>

1. Створюється попередня функція екшенів, в нашому випадку invokeAction, в якій за подомогою switch прописуємо всі кейси для роботи з базою данних. В нашому випадку (отримання всіх бордів, отримання одного борду по id, додавання борду, оновлення борду, видалення борду, додавання таски в борд, видалення таски в борд, оновлення таски). 

2. Створюється так званий сервіс у якому прописуються функції які отримають данні із екшенів для обробки дошок та тасок.  
Щоб прочитати те що користувач написав в консолі використовуєтсья массив  process.argv. Пишимо в консолі node app --action list. Або використовують пакети Yargs або Commander.

/* Express найпопулярніша бібліотека для створення веб серверів*/

1. Після створення серверу, при використанні методу get для відправки відповіді на запит краще використовувати метод json, наприклда res.json(data). Бо json метод може повернути null а метод send не може. Стандартний сервер: 

import express from "express"
const app = express();
app.get("./data", (req, res) => {
  res.json(data);
});
app.listen(3000, () => console.log("Server running on PORT 3000"));

Для перевірки запитів використовуй Postman

2. Middleware (далі MW) - проміжні обробки. Необхідні дії, які потрібно передати перед відправкою відповіді з сервера. 
  Схема: 
Frontend => Web-server => middleware1 => middleware2 => app.get("/data", (res, next)=>{});

Щоб створити MW потрібно викликати метод "use", метод приймає першим арг. маршрут, а другим колбек. Якщо передати колбек без маршуту, то MW спрацює для всіх запитів. 

app.use((req, res) => {console.log("First middleware")})

Express обробляє запити по черзі, тому після знаходження першого співпадіння він зупиняється. 
Якщо першим буде знайдений MW без маршруту то відповіді від сервера на фронтенд не буде. Тому MW і називається проміжним. Він повинен щось обробити і відправити запит далі. Тому третім аргументом в колбек ф-ції передається ф-ція next. Якщо викликати next() в колбеку то він каже експресу що треба шукати далі. 
Таким яином можно використовувати MW не одну. 

app.use((req, res, next) => {console.log("First middleware");
next(); 
})

Тому MW котру треба виконати перед будь-яким маршрутом потрібно викликати на початку. 
Частіше всього MW використовується для обробки CORS запитів. 


3. CORS - cross original request (запит з одного домену на інший). 

app.use((req, res, next) => {
  // Дозвіл запитів з конкретних джерел
  res.setHeader('Access-Control-Allow-Origin', '*');
  // Дозвіл певних методів запиту
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE');
  // Дозвіл певних заголовків у запиті
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  //Дозвіл відправлення куки та аутентифікації
  res.setHeader('Access-Control-Allow-Credentials', true);
  // Перехід до наступної middleware
  next();
});

Але так не пишуть а використовують пакет CORS.

import express from "express"
import cors from "cors"

const app = express();
const corsMiddleware = cors();
app.use(corsMiddleware);

app.get("./data", (req, res) => {
  res.json(data);
});
app.listen(3000, () => console.log("Server running on PORT 3000"));

Якщо приходить запит на адресу якої нема то прописуємо мідлвар для обробки помилки: 

app.use((req, res) => {
  res.status(404).json({
    message: "Not found"
  })
})

4. REST API - основні правила. 
Адреса запиту починається з іменника в множині, який вказує на обʼєкт:
 /products, /boards, /users 

CRUD-операція визнається методом HTTP-запиту, а не адресою: 
GET /boards - повернути всі дошки. 
POST /boards - додати одну дошку.

Якщо треба звернутися до одного обʼєкту то в кінці маршурут через / додають id цього обʼєкту:
GET /boards/1 - повернути дошку з id 1;
DELETE /boards/2 - видалити дошку з id 2;

Якщо запит повертає данні а не розмітку то починати адресу краще з /api:
/api/boards

Якщо хочете мати кілька версій API, то версію краще додавати до адреси: 
/api/v1/boards
/api/v2/boards

5. Правила відповідей REST API
Як пройшла обробка запиту на бекенді визначає статус відповіді: 
200 - OK
201 - Created
204 - No Content

301 - адреса переїхала на завжди
302 - адреса переїхала тимчасово

400 - Bad Request помилка в тілі запиту
401 - Unauthorized
403 - Forbidden
404 - Not Found - не знайдена адреса або обʼєкт з таким id
409 - Conflict

помилки сервера
500 - Server error

При додаванні або оновлені у відповідь треба відправляти обʼєкт з id 

6. Створюємо маршрути boards.
7. Якщо працюємо з JSON - Створюємо папку models, там створюємо папку boards, закидуємо нашу базу даних та файл index.js в якому прописуємо функції які считують та перезаписують наш JSON. 
7. Створюємо контролери для роутів також в окремій папці. У тих контролерах де необхідно отримувати дані від динамічних параметрів, використовуємо req.params. 
Помилки. 
- У разі якщо переданий не існуючий id потрібно створити, та обробити цю помилку. Так як майже в кожному контролері буде така обробка, створемо хелпер функцію для обробки такої помилки - HttpError.
- Майже в кожному контролері повторюється код обробки помилки сервера, тому в аргументи контролера додаємо третій аргумент next і визиваєм цю функцію в блоці catch прокидуючи в неї error. Таким чином помилка буде оброблена в мідлварі app.js 
Схема така: 
index.js (ф-ції для зчитування та зміни бази) => Controllers робить запит до бази даних, обробляє помилки (якщо вони є) та відправляє відповідь на фронтенд => Routes.

8. POST - запит. Для того щоб щось додати в БД використовуэться метод POST. 
Для тестування в постмені: метод POST, body => row => JSON та створюємо обʼєкт котрий ми будемо додавати в базу.
!!!! Якщо ми очікуємо дані в форматі JSON то потрібно використовувати мідлвар app.use(express.json())
<!-- -------------------------------------------------- -->
app.use(express.json()) - це middleware в Express.js, який додає функціональність для розбору тіла запиту у форматі JSON.
Коли сервер отримує запит із заголовком Content-Type: application/json, цей middleware спрацьовує і розбирає тіло запиту, перетворюючи його в об'єкт JavaScript, який потім стає доступним у властивості req.body для обробки в обробниках маршрутів.
Отже, цей middleware дозволяє легко працювати з даними у форматі JSON, які відправляються клієнтом, всередині вашого Express-додатка.
<!-- --------------------------------------------------- -->
Таким чином ми передаємо в функцію req.body
Якщо додавання успішне то обовʼязково прописуємо статус 201: res.status(201).json(result). 

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Обовʼязково потрібно перевірити чи ми отримали всі необхідні дані з фронтенду.Хоч бекенд і повинен перевіряти те що відправляється,та бекенд ніколи не повинен довіряти фронтенду!!
Для перевірки данних що приходять використовують бібліотеки, одна з таких - Joi. 
Створюємо схему обʼєкта як він має виглядати. Потім на цій схемі викликаємо метод і прокидуємо обʼєкт котрий відправляємо validate(req.body). Робимо if - якщо при перевірці виявилося що прийшов обʼєкт з невірними даними - визиваємо хелпер помилок HttpError, якщо все ок то записуємо новий обʼєкт в базу даних. Краще зробити свій текст помилки. 

Також створюємо мідлвару isEmptyBody для обробки пустого обʼєкта та імпортуємо у роути, та вставимо після вказання маршруту. 

9. PUT запит - метод оновлення. При оновленні повертаємо оновлений обʼєкт. Робимо схему для валідації, перевіряємо чи нормальний обʼєкт, якщо ні то обробляємо помилку, передаємо в наш метод id і req.body, обробляємо помилку якщо такого id не існує, якщо все ок повертаємо новий, оновлений обʼєкт. 

10. DELETE запит - метод видалення. Забираємо id з req.params, прокидуємо в наш метод, перевіряємо чи є такий id, якщо немає - обробляємо помилку, повертаємо видалений обʼєкт або статус 204. 

11. Декоратор - функція яка повертає функцію, ця функція отримає ф-цію у якості аргументу, створює ф-цію обгортку, яка викликає наш контроллер, і повртає нам цю обгортку - ctrlWrapper. Так як в кожному контролері ми використовуємо try/catch код виглядає обʼємно. Декоратор направлений на зменшення коду в одному файлі. 
Зробимо ще один декоратор validateBody для контролерів які прокидують помилку у разі якщо не пройдено валідацію. Потім у роутах визиваєио цю функцію в тих запитах де потрібно проводити валідацію, також імпортуємо схеми валідації в роути. В контроллерах видаляємо все зайве. 

12. MongoDB. 
--> Створюємо новий проєкт
--> Налаштовуємо проєкт. 
Security: Database access, Network access. 
Database access => Add New DB User => створюємо користувача => Built-in-Role => Atlas admin (ця роль дозволяє також і видаляти ваші бази данних) => Add user
Network access (створюємро список IP адрес з яких можна підключатись до нашої бази)  => Add IP address => allow access from anywhere

--> Створюємо базу данних:
Database => Built data base => обираємо тарифний план, обираємо регіон знаходження бази данних та жмакаємо create

Повертаючись у вкладку Database ми бачемо наш кластер. Зʼявиться кластер. У ньому нажимаємо Browse Collections => Add my own database => Створюємо свою базу. 

Вебінтерфейс працює дуже повільно, тому краще користуватись програмою "Mongo DB compass"
Щоб підключити нашу базу у Mongo DB compass в веб MongoDB заходимо у Database і в кластері натискаємо Connect => Compass => копіюємо та вставляємо в компас і підставляємо замість password наш пароль від бази данних. 

13. Підключення проєкту до бази данних. 
Для підключення необхідно інсталювати пакет mongodb driver або Mongoose (зручніший та частіше використовують). 
=> Підключаємося до бази данних в файлі server.js => імпортуємо mongoose => викликаємо метод connect() => першим аргументом передаємо рядок підключення до бази даних. Рядок знаходиться Database => Connect => Drivers. Вставляємо пароль, після останього слеша перед знаком ? треба написати назву бази до якої ми хотімо підключитись (якщо цього не зробити то буде автоматично створена база "test"). Підключення вебсерверу потрібно робити в connect().then(), а в catch треба прописати інструкцію process.exit(1) - це закриє всі процесси у разі помилки;

на гіті не можна зберигити логіни та паролі! Потрібно створити файл config.js, туди перенести рядок підключення та додати його в gitignore, але це поломає деплой. 
У кожномоу хостингу є така штука як змінні оточенння або "Environment" де ми можемо додати додаткову інформацію для хостингу. 
Існує обʼєкт process.env - це глобальний обʼєкт налаштувань компа на якому знаходиться проєкт. 
В Environment Variables потрібно додати ключ DB_HOST і його значення. 
у server.js ми беремо з обєкту process.env

const { DB_HOST } = process.env;

14. Deploy. Перед деплоєм треба вказати версію node.js:
"engines": {"node": "20.11"},

Робимо деплой на render.com. Add new => Web Service => Create 
